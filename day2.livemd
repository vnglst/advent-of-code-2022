# Day 2

```elixir
Mix.install([
  {:kino, "~> 0.7.0"}
])
```

## Small dataset

```elixir
games = "A Y
B X
C Z" |> String.split("\n") |> Enum.map(fn str -> String.split(str, " ") end)

defmodule Game do
  # A = Rock, B = Paper, C = Scissors
  # X = Rock, Y = Paper, Z = Scissors
  defp outcome(["A", "X"]), do: 3
  defp outcome(["A", "Y"]), do: 6
  defp outcome(["A", "Z"]), do: 0
  defp outcome(["B", "X"]), do: 0
  defp outcome(["B", "Y"]), do: 3
  defp outcome(["B", "Z"]), do: 6
  defp outcome(["C", "X"]), do: 6
  defp outcome(["C", "Y"]), do: 0
  defp outcome(["C", "Z"]), do: 3

  # X = Rock = 1, Y = Paper = 2, C = Scissors = 3
  defp basis([_, "X"]), do: 1
  defp basis([_, "Y"]), do: 2
  defp basis([_, "Z"]), do: 3

  def play(game), do: basis(game) + outcome(game)
end

games |> Enum.map(&Game.play/1) |> Enum.sum()
```

## Large dataset

```elixir
input = Kino.Input.textarea("Please add your input from Advent of Code")
```

```elixir
all_games =
  input
  |> Kino.Input.read()
  |> String.split("\n")
  |> Enum.map(fn str -> String.split(str, " ") end)

all_games |> Enum.map(&Game.play/1) |> Enum.sum()
```

## Part 2

```elixir
games = "A Y
B X
C Z" |> String.split("\n") |> Enum.map(fn str -> String.split(str, " ") end)

defmodule Game do
  @rock_value 1
  @paper_value 2
  @scissors_value 3

  # X = lose, Y = draw, Z = win
  defp outcome([_, "X"]), do: 0
  defp outcome([_, "Y"]), do: 3
  defp outcome([_, "Z"]), do: 6

  # A = Rock, B = Paper, C = Scissors
  defp get_value(game) do
    case game do
      ["A", "X"] -> @scissors_value
      ["A", "Y"] -> @rock_value
      ["A", "Z"] -> @paper_value
      ["B", "X"] -> @rock_value
      ["B", "Y"] -> @paper_value
      ["B", "Z"] -> @scissors_value
      ["C", "X"] -> @paper_value
      ["C", "Y"] -> @scissors_value
      ["C", "Z"] -> @rock_value
    end
  end

  def play(game), do: outcome(game) + get_value(game)
end

games |> Enum.map(&Game.play/1) |> Enum.sum()
all_games |> Enum.map(&Game.play/1) |> Enum.sum()
```

## Refactor attempt

This code is probably better, as the intent is more explicit. But it's also longer and more verbose. Keeping both variants for reference.

```elixir
defmodule Formatter do
  # A = Rock, B = Paper, C = Scissors
  defp player(str) do
    case str do
      "A" -> :rock
      "B" -> :paper
      "C" -> :scissors
    end
  end

  # X = lose, Y = draw, Z = win
  defp outcome(str) do
    case str do
      "X" -> :lose
      "Y" -> :draw
      "Z" -> :win
    end
  end

  def format([player1, outcome]), do: [player(player1), outcome(outcome)]
end

defmodule Game do
  @rock_value 1
  @paper_value 2
  @scissors_value 3

  defp outcome([_, :lose]), do: 0
  defp outcome([_, :draw]), do: 3
  defp outcome([_, :win]), do: 6

  defp get_value(game) do
    case game do
      [:rock, :lose] -> @scissors_value
      [:rock, :draw] -> @rock_value
      [:rock, :win] -> @paper_value
      [:paper, :lose] -> @rock_value
      [:paper, :draw] -> @paper_value
      [:paper, :win] -> @scissors_value
      [:scissors, :lose] -> @paper_value
      [:scissors, :draw] -> @scissors_value
      [:scissors, :win] -> @rock_value
    end
  end

  def play(game), do: outcome(game) + get_value(game)
end

small_set =
  "A Y
B X
C Z"
  |> String.split("\n")
  |> Enum.map(fn str -> String.split(str, " ") end)
  |> Enum.map(&Formatter.format/1)
  |> Enum.map(&Game.play/1)
  |> Enum.sum()

large_set =
  input
  |> Kino.Input.read()
  |> String.split("\n")
  |> Enum.map(fn str -> String.split(str, " ") end)
  |> Enum.map(&Formatter.format/1)
  |> Enum.map(&Game.play/1)
  |> Enum.sum()
```
